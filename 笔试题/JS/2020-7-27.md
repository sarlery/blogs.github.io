# 面试题

## 如何理解作用域和作用域链？  

JavaScript 中的作用域就是词法作用域。**词法作用域** 是一套关于引擎如何寻找变量以及在何处找到变量的规则。  

词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用 `eval()` 和 `with`）。  

**词法作用域是由书写代码时函数声明的位置决定的。**

### 函数作用域
JavaScript 具有基于函数的作用域，属于这个函数的全部变量都可以在整个函数的范围内使用。

### 动态作用域

动态作用域并不关心函数和作用域是如何声明以及在何处声明的，它只关心 **从何处调用**。即：作用域链是基于调用栈的，而不是代码的作用域嵌套。  

事实上 JavaScript 并不具有动态作用域，它只有词法作用域。但是 `this` 机制在某种程度上很像动态作用域。  

### 块作用域

ES6 之前，可以使用 `with` 和 `catch` 或者立即执行函数（IIFE）的方式模拟块作用域，例如：  

```js
try{
    throw 1;
}catch(e){
    console.log(e); // 1
}
console.log(e);     // 会报错

(function(){
    // ...
})()
```

`ES6` 中引入了 `let`，可以创建完整的、不受约束的块作用域。let 关键字可以将变量绑定到所在的任意作用域中（通常是 `{...}` 内部）。即：let 为其声明的变量隐式地劫持了所在地块作用域。  

### 作用域链


### 闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。  

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

## this 指向

`this` 关注函数如何调用。`this` 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时地各种条件。`this` 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式（而不是声明位置）。  

非严格模式下，`this` 默认绑定到 `window` 上，严格模式下 `this` 会绑定到 `undefined`。  

箭头函数不能显示地绑定 `this`，即用 `call`、`apply` 和 `bind` 绑定 this 时，箭头函数会忽略第一个参数。  

箭头函数并不关心 this 绑定。在箭头函数中使用 `this` 时，使用词法作用域中的 this。

