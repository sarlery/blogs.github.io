# 条目

## 1. 渐进增强与优雅降级

**渐进增强** 并不是一种技术，而是一种设计思想。各个浏览器的渲染能力各不相同，要做一个每个人都能看到的网页、感受到的体验都一致的网站几乎不可能。但还是得网站的可访问性，保证用户在任何环境下都能正常访问网页得核心内容或能使用基本功能（避免网页打不开、排版错误等），并为他们提供当前条件下最好的体验，这就是渐进增强得核心思想。  

**优雅降级** 也是一种设计思想，为了保证在高版本浏览器中提供最好的体验，碰到低版本浏览器再降级进行兼容处理，使其能正常浏览。  

这两种思想得区别在于：  

1. 渐进增强是向上兼容，优雅降级是向下兼容；
2. 渐进增强是从简单到复杂，优雅降级是从复杂到简单；
3. 渐进增强关注的是内容（保证核心内容），优雅降级关注的是浏览体验（为了兼容低版本浏览器）


## 2. BFC

`BFC` 全称 Block Formatting Context，翻译过来就是块格式化上下文，它是 CSS 规范的一部分。  

可以用一些 CSS 属性为一个元素创建出 BFC。决定元素的内容如何渲染以及与其他元素的关系和交互。BFC 有一个重要的特点：具有隔离作用。  

通过下列方式可以创建块格式化上下文：  

- 根元素 `<html>`；
- 浮动（`float`，但值不能是 `none`）；  
- 绝对定位元素（`position` 为 `absolute` 或者 `fixed`）；
- `overflow` 值不为 `visible` 的块元素；
- 行内块元素（`display` 为 `inline-block`）；
- `display` 为 `flow-root`，它可以创建无副作用的 BFC；
- 弹性元素（`display`为 `flex` 或 `inline-flex` 元素的直接子元素）；
- 网格元素（`display` 为 `grid` 或 `inline-grid` 元素的直接子元素`）；
- 多列容器（元素的 `column-count` 或 `column-width` 不为 `auto`）；
- 表格单元格（`display` 为 `table-cell`，HTML 表格单元格默认为该值）；
- 表格标题（`display` 为 `table-caption`，HTML表格标题默认为该值）；
- 匿名的表格单元格元素（元素的 `display` 为 `table`、`table-row`、`inline-table` 等）； 

BFC 应用举例：解决 margin 塌陷问题；子元素浮动后父元素没有高度问题；

### 总结

BFC 即：格式化上下文，它既不是一个 CSS 属性，也不是一段代码，而是 CSS2.1 规范中的一个概念，决定元素的内容如何渲染以及与其他元素的关系和交互。BFC 有五条规则：  

1. BFC 有隔离作用，内部元素不会受外部元素的影响（反之亦然）。
2. 一个元素只能存在于一个 BFC 中，如果能同时存在于两个 BFC 中，那么就违反了 BFC 的隔离规则。  
3. BFC 内的元素按正常流排列，元素之间的间隙由元素的外边距（margin）控制。
4. BFC 中的内容不会与外面的浮动元素重叠。
5. 计算 BFC 的高度，需要包括 BFC 内的浮动子元素的高度。   

## 3. 选择器权重

|类型|例子|权重|
|:---|:---|:---|
|ID选择器|`#root`|100|
|class选择器|`.wrapper`|10|
|属性选择器|`[type='text']`|10|
|标签和伪类|`div`|1|
|伪元素|`::first-letter`|1|
|行内样式|`<p style="height:20px">`|1000|
|通配符|`*`|0|  

关系选择符（`a+b`、`a>b`、`a b`、`a~b`）与通配符一样，都是没有权重的。  

如果一个样式属性后面加上 `!important` 规则，此声明将覆盖任何其他声明。也可以认为它的优先级是最高的。  

### 继承和通配符

例如下面的代码：  

```html
<style>
  *{
    color: red;
  }
  p{
    color: green;
  }
</style>
<p>OK!!!
  <span>span span</span>
</p>
```

问 `span` 元素的字体颜色是什么颜色？  

答案是 `red`，这说明通配符的权重要比继承大。如果去掉通配符，那么 `span` 的字体颜色将继承 `p` 元素的字体颜色。  

### 组合选择器

1. 在下列关系选择器中，找出相邻选择器，能匹配相邻兄弟元素的是？  

A. .bfc+div  
B. .bfc div  
C. .bfc>div  
D. .bfc~div  

> 答案是 A

第二个选项表示后代选择器，儿子元素、孙子元素都可以选择到；  
第三个选项表示子代选择器，只有 .bfc 的子元素可以选择到；  
第四个选项表示通用的兄弟选择器，不管相不相邻都可以选择到；  

2. 以下属性选择器表示属性值以“val-”开头的是？  

A. [attr^="val"]  
B. [attr~="val"]  
C. [attr|="val"]  
D. [attr$="val"]  


> 答案 C  

属性选择器通过已经存在的属性名或属性值匹配元素。例如：  

```css
input[type="text"]{
  color: red;
}
```

- `[attr^="val"]` 表示属性值以 `val` 开头，题目是说以 `val-` 开头，所以不正确；  
- `[attr~="val"]` 表示属性值用空格分割为多个值，其中至少有一个值是 `val`，例如 `class` 属性就可以有多个值；  
- `[attr|="val"]` 表示带有以 `attr` 命名的属性的元素，属性值为 `val` 或以 `val-` 为前缀。选取有自定义属性的元素时可以使用该选择器（`data-*`）。  
- `[attr$="val"]` 表示属性值以字符串 `val` 结尾；
- `[attr*="val"]` 表示选取 attr 属性值中包含 `val` 字符串的元素。  

除此之外，还有一种格式：  

```css
[attr operator value i]
```

它表示在属性选择器的右方括号前添加一个用空格隔开的字母 i（或 I，大小写不敏感），可以在匹配属性值时忽略大小写。如：  

```css
/* 包含 "insensitive" 的链接,不区分大小写 */
a[href*="insensitive" i] {
  color: cyan;
}

/* 包含 "cAsE" 的链接，区分大小写 */ 
a[href*="cAsE" s] { 
  color: pink; 
}
```

## 4. 事件对象

#### 1. 在事件对象中，target 与 currentTarget 有什么不同？  

`target` 属性指向的是事件目标，而 `currentTarget` 属性指向的是正在处理当前事件的对象，它总是指向事件绑定的元素。而 `target` 指向的可能不是定义时的事件目标。  

例如：

```js
div.addEventListener('click', (e) => {
    console.log(e.target, e.currentTarget);
},false);
```

`e.target` 可能指向 `div` 元素，也可能指向它的子元素。而 `e.currentTarget` 总是指向 `div` 元素。  

### 冒泡与捕获

事件冒泡与捕获是事件处理的两种机制，**主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。**    

再点击子元素时，浏览器运行了两种不同的阶段：捕获阶段和冒泡阶段。捕获阶段的行为：  

- 浏览器检查元素的最外层祖先`<html>`，是否在捕获阶段中注册了一个`onclick`事件处理程序，如果是，则运行它；
- 然后，它移动到`<html>`中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素；  

而冒泡与捕获恰恰相反：  

- 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个`onclick`事件处理程序，如果是，则运行它；
- 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达`<html>`元素；  

而现代浏览器在默认情况下，所有事件处理程序都在冒泡阶段进行注册。因此上面代码在点击子元素时会先执行子元素绑定的事件，然后向上冒泡，触发父元素绑定的事件。  

`addEventListener` 函数的第三个参数是个布尔值。含义：
- 当布尔值是 `false` 时（这也是默认值），表示向上冒泡触发事件；
- 当布尔值是 `true` 时，表示向下捕获触发事件；  

### 不能冒泡的事件

有些事件是不会冒泡的。比如：  

- `blur` 元素失去焦点时触发，`focusout` 事件也是失去焦点时触发，但可以冒泡；
- `focus` 元素获取焦点时触发；
- `mouseenter` 鼠标移动到元素上时会触发该事件，与之对应的是 `mouseover` 事件，但会冒泡； 
- `mouseleave` 鼠标离开元素时触发，与之对应的是 `mouseout`，但会冒泡；  

事件冒泡可以让我们利用事件委托，尤其是处理大量子元素时，如果给每个子元素都绑定事件，这是不优雅的，可以将事件绑定到父元素上，并让子节点上发生的事件冒泡到父节点上，利用 `e.target` 属性可以获取到当前触发事件的子元素。  

### 事件对象中的方法

- `stopPropagation()` 阻止事件冒泡，当设置后，点击该元素时父元素绑定的事件就不会再触发；
- `preventDefault()` 阻止默认事件的发生；  
- `stopImmediatePropagation()` 它用来阻止监听同一事件的其他事件监听器被调用以及阻止事件冒泡，比如给同一个 `div` 元素绑定多个 `click` 事件（使用 `addEventListener` 方法可以注册多个），当在第二个事件函数中调用 `stopImmediatePropagation` 方法时，点击 `div` 元素时，后面注册的 `click` 将不会被触发，而且还会阻止事件冒泡；  

> 在 IE 浏览器中，使用 `e.cancelBubble = true` 也可以取消事件冒泡；使用 `e.returnValue = false` 也能阻止默认事件的发生。

## 5. DOCTYPE

```html
<!DOCTYPE html>
<html>
    <!-- ... -->
</html>
```

### 作用

`DTD`（Document Type Definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文档类型。浏览器会使用它来判断文档类型，决定何种协议来解析，以及切换浏览模式。  
`DOCTYPE` 是用来声明文档类型和 DTD 规范的，一个主要的用途便是文件的合法性验证。如果文档代码不合法，那么浏览器解析时便会出现一些差错。  

HTML5 的文档类型声明：  

```html
<!DOCTYPE html>
```

HTML 4.01 Strict（HTML 4.01严格模式）的DTD包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（如`font`），它的文档类型声明：  

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

### 标准模式与怪异模式

怪异模式（Quirks Mode）用于模拟就浏览器的行为。早期的网站并不会遵循完整的规范，随着浏览器支持越来越多的规范，在那些旧的浏览器中开发的页面在显示时会被破坏。为了向后兼容，浏览器发明了怪异模式，一行错误或无效的 `DOCTYPE` 都会触发怪异模式。  

浏览器使用文件开头的 `DOCTYPE` 来决定用怪异模式处理或标准模式处理。`DOCTYPE` 可以确保不同浏览器以相同的方式解析文档，以及执行相同的渲染模式。

怪异模式与标准模式的主要区别：  

1. 怪异模式的宽度和高度会包含 `padding` 和 `border`。标准模式不包含，标准模式下可以通过设置 `box-sizing: border-box` 将标准盒模型转化成怪异模式下的盒模型。  

2. 怪异模式下，当内容超出容器高度时，会将容器拉伸，而不是溢出。  
3. 怪异模式下，在表格中的字体样式（如 font-size ）不会继承。
4. 怪异模式下颜色值必须使用十六进制表记法。

## 6. 语义化

HTML5 中的语义化就是让元素、属性或属性值有含义，更准确地标记特定类型的内容。对元素语义化的目的是为了让元素的语义和呈现分离，元素只负责文档内容的结构与含义，而 CSS 样式控制内容的呈现，像 `<b>` 元素，没有语义但却能将字体变粗，这类元素违背了语义化的目的，将会被废弃。

### 优点

- 使得 HTML 文档结构清晰、布局合理、主体突出、可读性更强。
- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
- 方便其他设备解析，如盲人阅读器根据语义渲染网页。
- 有利于开发和维护，语义化更具可读性，代码更好维护，与 CSS3 关系更和谐。  

### 语义化标签

- `<header>` 定义文档的页眉区域,应作为介绍内容或者导航链接栏的容器；
- `footer` 内容的页脚，通常包含该章节作者、版权数据或者与文档相关的链接等信息；
- `article` 文档、页面、应用或网站中的独立结构，是可独立分配的、可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目；
- `nav` 描述一个含有多个超链接的区域，该区域包含跳转到其他页面或页面内部其他部分的链接列表；
- `section` 表示文档中的一个区域（或节），比如，内容中的一个专题组；
- `main` 定义文档的主要内容，该内容在文档中应当是独一无二的，不包含任何在文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（搜索框作为文档的主要内容）；
- `aside` 表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。

## 7. 超链接伪类

`:link`、`:visited`、`:active` 和 `:hover` 的声明顺序是怎样的？  

`:link` 表示未访问的链接状态；  
`:visited` 表示已访问状态；
`:active` 表示激活状态（鼠标按下）；
`:hover` 表示悬停状态。  

推荐顺序是 `LVHA`，即 `:link` `:visited` `:hover` `:active`。理由如下：  

- 当鼠标悬停在未访问的链接上时，`:link` 和 `:hover` 都会命中，如果 `:hover` 在 `:link` 之前声明，那么(`:hover`)就会被覆盖；
- 当鼠标悬停在已访问的连接上时，`:visited` 和 `:hover` 都会命中，如果 `:hover` 在 `:visited` 之前声明，那么(`:hover`)就会被覆盖；
- 当鼠标单击链接时，`:active` 和 `:hover` 都会命中，我们大多是想让 `:hover` 只在悬停时展示样式，按下鼠标时使用 `:active` 样式，因此 `:active` 在 `:hover` 之后声明；
- 综上，`:hover` 应在 `:link` 和 `:visited` 之后，在 `:active` 之前，因此 `active` 在最后。而 `:link` 和 `:visited` 两者的顺序无所谓，互不影响。  

## 8. CSS 常见的长度单位

CSS 中除了 px 长度单位之外，还有下面几个长度单位：  

- `pc` 六分之一英寸，1pc = 12pt = 1/6 * 1in = 16px；
- `pt` 一磅，72 分之一英寸。1pt = 1/12 * 1pc = 1/72 * 1in ≈ 1.33px；
- `in` 一英寸，1in = 2.54cm = 96px；
- `ex` 在含有“X”字母的字体中，它是该字体的小写字母的高度。对于很多字体来说，1ex ≈ 0.5em；
- `em` 1em 等于父级元素的字体大小，2em 就是父级元素字体大小的二倍；
- `rem` 当用在根元素（`<html>`）的 font-size 上面时 ，它代表了它的初始值；
- `ch` 代表元素所用字体 font 中“0”这一字形的宽度；
- `vh` 1vh 相当于视口高度的 1%，100vh 就是视口的高度；
- `vw` 1vw 相当于视口宽度的 1%，100vw 就是视口的宽度；
- `vmax` 视口高度 vw 和宽度 vh 两者中的最小值
- `vmin` 视口高度 vw 和宽度 vh 两种中的最大值；
- `%` 相对于父级元素的大小来确定；  

参考：[CSS &lt;length&gt;](https://developer.mozilla.org/zh-CN/docs/Web/CSS/length)   

[CSS percentage](https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage)    

## 9. HTML 布尔属性

|属性|描述|
|:--|:--|
|`hidden`|该元素是否隐藏|
|`readonly`|控件的值不可编辑|
|`required`|控件的值是必填的|
|`multiple`|是否允许选取多个值|
|`checked`|该控件是否被选中|
|`disabled`|是否禁用该控件|
|`autofocus`|是否自动聚焦输入框|
|`selected`|`option` 元素初始是否被选中； |

> 这些值属性的值只要设置上就会认为是 `true`，例如可以这么写：`disabled='disabled'`，或者 `checked=''` 都会认为是 true，也就是说只要有这个字段，无论它是什么值，都会认为你设置了该属性，并且值是 `true`。要想移除这个属性，可以使用 `removeAttribute` 方法；或者获取到这个元素的 DOM，将属性设置成 `elem.checked = false`。  

## 10. href 和 src 的不同

两者的功能不同。`href`（hypertext reference）能够建立一条通道，将当前文档和定义的资源连接起来。src（source）是将定义的资源嵌入到当前文档中。 

## 11. Event Loop

JS 的单线程是指一个浏览器进程中只有一个 JS 的执行线程，同一时刻内只会有一段代码在执行。

## 12. 浏览器渲染过程

- CSS 加载不会阻塞 DOM 解析，但会阻塞 DOM 渲染；
- CSS 加载会阻塞 JS 执行，但不会阻塞 JS 下载；  

### defer 和 async 的区别

两者都是异步去加载外部JS文件，不会阻塞 DOM 解析；

- `async` 是在外部 JS 加载完成后，浏览器空闲时，Load 事件触发前执行，标记为 async 的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有「src」属性的脚本）。defer 是在 JS 加载完成后，整个文档解析完成后，触发 DOMContentLoaded 事件前执行，如果缺少 src 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。

### 重绘与重排

## 13. 性能优化

## 14. 错误处理






