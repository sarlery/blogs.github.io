# js 代码试题

### 1. 数组的 push 方法

var a = [].push(...[1, 2, 3]);

> 答案：3。  
 
#### 💡 **解析** 

`...` 是 ES6 中的扩展运算符，相当于：push(1, 2, 3); push 方法返回的是该数组的新长度。因此是 3。  

### 2. Set 数据结构存数据

var set = new Set([0, 2, 2, 0, 0, 5, 9, {}, {}, NaN, NaN]);

> 答案：7。 分别是：[0, 2, 5, 9, {}, {}, NaN]。  
 
#### 💡 **解析**

之所以有两个对象是因为对象是引用类型。而 NaN === NaN 总是返回 false，不应该也是两个吗？事实上，`NaN` 和 `undefined` 都可以被存储在 `Set` 中， NaN之间被视为相同的值（`NaN` 被认为是相同的，尽管 `NaN !== NaN`）。  

✅ **拓展**：考虑下面的代码 set 数据中有哪些值？  

```js
var a = new Set([undefined, undefined, null, null, -0, +0, NaN, "", ""]);
```

结果：Set(5) {undefined, null, 0, NaN, ""}


### 3. Object.is() 函数

考虑下面的代码输出结果为 true 还是 false？  

```js
console.log(Object.is(-0, +0));
console.log(Object.is(0, -0));
console.log(Object.is(0, +0));
console.log(Object.is(NaN, NaN));
console.log(Object.is(NaN, 0/0));
console.log(Object.is([],[]));
```

> 答案：`false`,`false`,`true`,`true`,`true`,`true`。  

#### 💡 **解析**

`Object.is()` 判断两个值是否相同。如果下列任何一项成立，则两个值相同：  

- 两个值都是 `undefined`；
- 两个值都是 null
- 两个值都是 true 或者都是 false
- 两个值是由相同个数的字符按照相同的顺序组成的字符串
- 两个值指向同一个对象
- 两个值都是数字并且：  
    - 都是正零 +0（没有符号的 0 相当于 +0）  
    - 都是负零 -0  
    - 都是 NaN  
    - 都是除零和 NaN 外的其它同一个数字  

可以看出，这种相等性判断逻辑和传统的 `==` 运算不同。`==` 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，但 `Object.is` 不会做这种类型转换。  

这与 `===` 运算符的判定方式也不一样。`===` 运算符（和 `==` 运算符）将数字值 `-0` 和 `+0` 视为相等，并认为 `Number.NaN` 不等于 `NaN`。  

上边例题中，Object.is(NaN, 0/0) 之所以为 true，是因为 0/0 等于 `NaN`。而 `0/2` 等于多少呢？`2/0` 又是等于多少呢？于是诞生出了下面几个问题：  

```js
console.log(Object.is(NaN, 0/2));       // false
console.log(Object.is(NaN, 2/0));       // false
console.log(Object.is(2/0, 0/2));       // false
console.log(Object.is(Infinity, 2/0));  // true 
console.log(Object.is(Infinity, Infinity));     // true
console.log(Object.is(-Infinity, -Infinity));   // true
```

在 JavaScript 中，0 除以一个不为零的数时，如果这个数是正数，则结果为 `+0`；如果这个数是负数，则结果是 `-0`。当一个不为零的数除以 0 时，当这个数是负数时，则结果是 `-Infinity`，表示负无穷；当这个数是正数时，则结果是 `Infinity`，表示正无穷；  

在 JavaScript 中，无论是 `==` 还是 `===`，`Infinity` 都等于自身，`-Infinity` 也是都等于自身。因此上面代码中，后三个结果是 `true`。

✅ **拓展**：如何实现这个方法？

```js
Object.is = function(x, y){
    // 如果两个值相等
    if (x === y) {
      // 让 -0 != +0 成立
      return x !== 0 || 1 / x === 1 / y;
    } else {    
       // 如果两个值不相等（如：NaN ！== NaN）
      // 让 NaN == NaN 成立
      return x !== x && y !== y;
    }
}
```

解释一下上面将 -0 != +0 成立的原理。加入参数 x 为 +0，y 为 -0，`x !== 0` 显然不成立（反过来也一样），然后看第二个条件，1/+0 等于 Infinity，1/-0 等于 -Infinity。因此也不行等，于是返回 `false`。  

**特例：** Object.is(0.2 + 0.1, 0.3);       // false

### 4. 字符串中的 replace 函数

考虑下面的代码执行结果是什么？  

```js
'a.b.c'.replace(/(.)\.(.)\.(.)/, '$2.$1.$0');
```
1.  cba  
2.  c.b.a  
3. ...  
4. b.a.$0

> 答案：第四个选项正确。  

#### 💡 **解析**

要做出来这道题目，需要先了解 `replace` 这个函数。replace 函数非常强大，它是用来匹配特定的字符串或正则表达式，然后把匹配到的结果替换成新的字符串的函数。一般我们使用 replace 时第一个参数是一个字符串或者正则表达式，第二个参数是一个字符串：  

```js
// 当第一个参数是字符串时，仅第一个匹配项会被替换。
"abcdcba".replace("a", "y");    // ybcdcba
// 正则表达式中的 g 参数表示全局匹配，有了它，所有匹配项都会被代替
"abcdcba".replace(/a/g, "y");    // ybcdcby
```

上面用法很常见。在正则表达式中你是否见过这样的表达式：  

```js
'abcdabc'.match(/^(\w+)\w*\1$/);
```
上面会匹配到。而且匹配到了两个。一个是全局的匹配字符，另一个是捕获（括号里的内容 abc）。在这个正则表达式里 `\1` 是一个 `反向引用`，指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。

在 `replace` 函数中，第二个参数可以插入下面的特殊变量名作为参数：  

|变量名|代表的值|
|:---|:---|
|`$$`|插入一个 "$"|
|`$&`|插入匹配的子串|
|$`|插入当前匹配的子串左边的内容|
|`$'`|插入当前匹配的子串右边的内容|
|`$n`|假如第一个参数是 `RegExp` 对象，并且 `n` 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串，**索引是从 1 开始**。  

`replace` 中的 `$n` 与正则表达式中的反向引用有些相似，而且都是 n 都是从 `1` 开始。因此上面的代码 `'$2.$1.$0'` 中的 `$0` 是没有意义的（一个普通的字符串）。`$2` 表示第左起二个括号，`$1` 表示左起第一个括号。于是被替换成了 `b.a.$0`。  

✅ **拓展**：`replace` 函数的第二个参数可以是一个函数。  

当第二个参数是一个函数时，当匹配执行后，该函数就会执行。函数的返回值作为替换字符串。另外要注意的是，如果第一个参数是正则表达式，并且其为`全局匹配模式`，那么这个方法将被多次调用，每次匹配都会被调用。这个函数有多个参数：  

|变量名|描述|
|:----|:-----|
|`match`|匹配的子串（对应于上述的 `$&`）|
|`p1,p2, ...`|假如 `replace()` 方法的第一个参数是一个 `RegExp` 对象，则代表第 `n` 个括号匹配的字符串。（对应于上述的`$1，$2`等。）|
|`offset`|匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 'abcd'，匹配到的子字符串是 'bc'，那么这个参数将会是 1）|
|`string`|被匹配的原字符串|  

下面的函数将所有出现的大写字母转换为小写，并且在匹配位置前加一个连字符（`-`）。

```js
function styleHyphenFormat(propertyName){
  function upperToHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  return propertyName.replace(/[A-Z]/g, upperToHyphenLower);
}
```

比如字符串是 `borderTop`，替换后将变成 `border-top`。


### 5. Array 方法中哪些方法会改变原始数组？  

执行下列语句后，`a.length` 的值为：  

```js
var a = [];
a.push(1, 2);
a.shift(3, 4);
a.concat([5, 6]);
a.splice(0, 1, 2);
```

> 答案：1。 

#### 💡 **解析**

- push 函数可以一次 push 多个元素（[1,2]），并**返回更新后的数组的长度**；  
- shift 没有参数，它表示删除数组的第一项元素，并**返回该元素的值**，会改变原来的数组（[1]）；
- concat 合并两个或多个数组，此方法不会更改现有数组，而是**返回一个新数组**（[1]）；
- splice 删除或替换现有元素或者原地添加新的元素来修改数组,并**以数组形式返回被修改的内容**。此方法会改变原数组（从下标 0 开始，删除 1 个元素，并从下标 1 开始插入一个元素 2，因此数组 a 变成了 [2]。`a.length` 等于 1）；

✅ **拓展**：Array 数组方法中哪些方法会改变原数组？ 

除了上面提到的 `push`, `shift`, `splice` 之外还有这么几个会改变原数组：  

1. `sort` 对数组的元素进行排序，并**返回数组**。默认排序顺序是在将元素转换为字符串，然后比较它们的`UTF-16`代码单元值序列时构建的。  
2. `pop` 弹出数组的最后一个元素，并**返回该元素的值**；
3. `unshift` 将一个或多个元素添加到数组的开头，并**返回该数组的新长度**；
4. `reverse` 将数组中元素的位置颠倒，**并返回该数组**；  
5. `copyWithin(target, start?, end?)` 方法浅复制数组的一部分到同一数组中的另一个位置，并**返回改变后的数组**，不会改变原数组的长度（例如：[1,2,3,4,5,6].copyWithin(4,0,2); 表示从下标0开始复制，一直复制到下标2结束，但不包括下标2，把复制的内容转移到下标为4的位置及其以后的位置，就变成了 `[1,2,3,4,1,2]`）；
6. `fill(value, start?, end?)` 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素，不包括终止索引，并**返回修改后的数组**；

> 后两个方法都是 ES6 或 ES7 新出的方法，因此兼容性可能不太好。

### 6. 数字与布尔的类型转换
考虑下面的代码，哪个是正确的？  

```js
var a = true;
var b = 1;
```

1. (a || b) === true;
2. (b || a) === true;  

> 答案：第一个正确。  

#### 💡 **解析**


### 7. JavaScript 数据类型

- 问：JavaScript 中有几种**原始数据类型**（有时候也叫基本数据类型）？  

答：六种，它们是一种既非对象也无方法的数据。分别是：`string`、`number`、`boolean`、`null`、`undefined`、`symbol`。  

- 问：除了原始数据类型还有哪些类型？  

答：除了原始数据类型就是引用类型，即：`Object` 对象类型。它是内存中的可以被标识符（指针）引用的一块区域。因此 `{} !== {}`，比较的是地址。  引用类型主要有：`Object`、`Array`、`Date`、`Function`、`Set`、`Map`、类型数组（比如 `Int8Array`）、`WeakMap`、`WeakSet`、`JSON`等。  

> 因此，Object 加上上面的六种原始数据类型，ECMAScript 标准定义了 7 种数据类型。

✅ **拓展**：第七种原始数据类型：`BigInt`



