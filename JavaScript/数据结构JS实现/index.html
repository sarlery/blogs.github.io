<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>
        // 链表
        const LinkList = (function () {

            class Node {
                constructor(value) {
                    this.value = value;
                    this.next = null;
                }
            }

            function isNum(val) {
                var num = Number(val);
                if (Number.isNaN(num)) {
                    throw new TypeError(`${val} is not a number`);
                }
            }


            let list = new WeakMap();

            return class LinkList {
                constructor(...items) {
                    if (items.length) {
                        list.set(this, new Node(items[0]));
                        for (let i = 1, len = items.length; i < len; i++) {
                            this.append(items[i]);
                        }
                    }
                }

                removeAt(idx) {
                    isNum(idx);
                    var idx = idx >= 0 ? idx : this.size() + idx;
                    var link = list.get(this);
                    if (!link || idx > this.size() - 1) {
                        return false;
                    }

                    if (idx === 0) { // 要删除的是第一项
                        var current = link.next;
                        // 如果链表长度是 1，则直接删除链表
                        if (!current) {
                            list.delete(this);
                        } else {
                            // 长度大于 1 时，将第一项剔除
                            list.set(this, current);
                        }
                    } else {
                        // 如果删的不是第一项
                        while (idx) {
                            var prevNode = link;
                            link = link.next;
                            idx--;
                        }
                        prevNode.next = link.next;
                    }
                    return link.value;
                }

                remove(elem) {
                    var idx = this.indexOf(elem);
                    return idx !== -1 ? this.removeAt(idx) : false;
                }

                isEmpty() {
                    return this.size() ? false : true;
                }

                values() {
                    var link = list.get(this),
                        vs = [];
                    while (link) {
                        vs.push(link.value);
                        link = link.next;
                    }
                    return vs;
                }

                insert(idx, elem) {
                    isNum(idx);
                    var idx = idx >= 0 ? idx : this.size() + idx,
                        link = list.get(this);

                    if (idx === 0) {
                        var head = new Node(elem);
                        head.next = link;
                        list.set(this, head);
                    }
                    while (idx) {
                        var prevNode = link;
                        link = link.next;
                        idx--;
                    }
                    prevNode.next = new Node(elem);
                    prevNode.next.next = link;
                }

                indexOf(elem) {
                    var link = list.get(this),
                        idx = 0;
                    if (!link) {
                        return -1;
                    }
                    while (link) {
                        if (link.value === elem) {
                            return idx;
                        }
                        link = link.next;
                        idx += 1;
                    }
                    // 没有遍历到，则返回 -1
                    return -1;
                }

                size() {
                    var link = list.get(this),
                        size = 0;
                    if (link) {
                        size = 1;
                        while (link.next) {
                            size += 1;
                            link = link.next;
                        }
                    }
                    return size;
                }

                append(item) {
                    var link = list.get(this);
                    if (!link) {
                        list.set(this, new Node(item));
                    } else {

                        while (link.next) {
                            link = link.next;
                        }
                        link.next = new Node(item);
                    }
                }

                clear() {
                    list.delete(this);
                }

                toString() {
                    var link = list.get(this);
                    return link;
                }
            }

        })();

    </script>


    <script>
        function HashTable(object) {
            let table = []; // 存入哈希表的一个数组
            // 写成两个回调函数，减少了反复的条件判断
            function keyIsNumOrStr(key, value, strFn, numFn) {
                if (typeof key === 'string') {
                    return strFn(key, value);
                } else if (typeof key === 'number') {
                    return numFn(key, value);
                } else {
                    throw new TypeError('The key must be a string or a number');
                }
            }

            function getHashValue(str) {
                var num = 0;
                for (let i = 0, len = str.length; i < len; i++) {
                    num += str.codePointAt(i);
                }
                return num % 37;
            }

            function putElem(idx, key, value) {
                if (!table[idx]) {
                    table[idx] = [];
                    table[idx].push({
                        key,
                        value
                    });
                } else {
                    table[idx].push({
                        key,
                        value
                    });
                }
            }

            this.put = function (key, value) {
                keyIsNumOrStr(key, value, function (key, value) {
                    let hashVal = getHashValue(key);
                    putElem(hashVal, key, value);
                }, function (key, value) {
                    putElem(key, key, value);
                });
            }

            if (object) {
                if (Object.prototype.toString.call(object) !== '[object Object]') {
                    throw new TypeError('this arguments must be object');
                } else {
                    for (let props in object) {
                        this.put(props, object[props]);
                    }
                }
            }

            this.get = function (key) {
                return keyIsNumOrStr(key, null, function (k) {
                    var hashVal = getHashValue(k);
                    if (!table[hashVal]) return undefined;
                    else {
                        return table[hashVal].filter(item => item.key === k)[0].value;
                    }
                }, function (k) {
                    if (!table[k]) return undefined;
                    return table[k].filter(item => item.key === k)[0].value;
                });
            }

            this.remove = function (key) {
                return keyIsNumOrStr(key, null, function (key) {
                    var hashVal = getHashValue(key);
                    if (!table[hashVal]) return undefined;
                    else {
                        var idx = table[hashVal].findIndex((elem, idx) => elem.key === key);
                        return table[hashVal].splice(idx, 1)[0].value;
                    }
                }, function (key) {
                    if (!table[key]) return undefined;
                    else {
                        var idx = table[key].findIndex((elem, idx) => elem.key === key);
                        return table[key].splice(idx, 1)[0].value;
                    }
                });
            }

            this.print = function () {
                return table;
            }
        }

    </script>

</body>

</html>
