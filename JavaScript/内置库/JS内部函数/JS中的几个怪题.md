# JS中几个不可思议的题目
整理了在 JavaScript 中几个几个 “脑筋急转弯” 式的题目，这些题目一般都与 JS 这门语言的语言特性有关，当充分了解这些内置方法后，题目自然也就很好解决了！  
## 1. parseInt 与 array.map 的结合
看下面代码，程序运行后会输出什么？
```js
var arr = ['1','2','3'].map(parseInt);
console.log(arr);
```
想要解出这个题目，首先要了解 `map` 方法和 `parseInt`。这两个方法在平时使用的频率是很高的，对于 map 方法肯能都很熟悉，经常用它来操作数组，然后返回一个新的数组，比如下面的例子，给了一个数组，让原数组中的大写字母都变成小写字母形式：
```js
var words = ["wAterMelon","Pear","apple","GRapE"];
// toLocaleLowerCase 方法可以将大写转成小写
var fruits = words.map(item => item.toLocaleLowerCase());
```
> map 的回调函数接收两个参数，分别是 item（数组的每一项）、index（数组的索引）
需要注意的是：map 方法返回的数组的长度是与原数组一样的。不应该使用 map 方法来做筛选操作（筛选应该考虑使用 filter、some等方法），map 是对数组中每个元素的操作。比如下面例子，我们想要筛选出年龄大于 18 的人群：
```js
var persons = [
    {name: '小明',age: 18},
    {name: '小刚',age: 16},
    {name: '老王',age: 66},
    {name: '小李',age: 20},
    {name: '老张',age: 40}
];

var result = persons.map(item => {
    if(item.age > 18){
        return item;
    }
});
```
使用 map 方法返回的结果却是这样的：`[undefined, undefined, {…}, {…}, {…}]` 因为有两个不满足（就是前两个），它却返回 undefined，可见，map 方法返回的数组的索引与原数组的索引是对应的。想要对上面做筛选，做好的办法就是使用 `array.filter` 方法：
```js
var result = persons.filter(item => item.age > 18);
```
下面来说一下 `parseInt`
这个方法应该也不会陌生，在处理 CSS 尺寸时会经常用到它，这个函数主要是为了从字符串中提取出含有整数数字的部分。比如：
```js
parseInt('-123abc');    // -123 (去除字母)
parseInt('-1c2abc');     // -1   (只会获得左边第一个匹配到的数字)
parseInt('12.33');      // 12    (只会匹配整数，小数部分剔除)
```
很多人都知道 parseInt 的第一个参数，它是一个字符串，parseInt 还可以指定第二个参数，用来指定进位基数，默认是十进制，当匹配不到指定的数值时，则会返回 NaN。需要注意的是：**传入的第二个参数，并不是让第一个参数转成对应的几进制，而是指：第二个参数是几进制，那么就认为第一个参数会是几进制！**比如下面的例子：
```js
parseInt("0110",2);     // 6，第二个参数是二进制，那么就认为第一个参数是一个二进制数
parseInt("0110.11",2);      // 6，同样会忽略小数部分

// NaN，第二个参数是七进制，但是第一个参数却不是七进制！
parseInt("87",7);         
parseInt("8a7",8);   // 同样返回 NaN，因为 只会获得左边第一个匹配到的数字
```
对于这道题目，还需要了解一个用法，在 `parseInt` 的第二个参数中还可以传数字 `0`，这个也表示八进制，还可以传字符串`0x`，表示十六进制。表示十六进制时需要注意：
```js
parseInt("8a7",'0x');       // 8
// 有十六进制中的 a-f 时，字符前应加 "0x"
parseInt("0x8a7",'0x');     // 2215  
```
说了那么多，这道题已经出来答案了。因为 map 方法的回调刚好接收两个参数 —— item（数组每一项） 和 index（每一项的索引）。显然 index 是从 0 到 2 在这个题目当中。这就相当于：
```js
// 原数组：['1','2','3']

parseInt('1',0);    // 0 表示八进制，所以返回 1
parseInt('2',1);    // 没有一进制，返回 NaN
parseInt('3',2);    // 二进制中没有数字 3，返回 NaN
```
最后答案：`[1,NaN,NaN]`

## 2.怪异的相等
看下面程序，变量 a 等于什么时，可以让等号成立（为真正值）:
```js
console.log(a == 1 && a == 2 && a == 3);    // true
```
看到这个题目，顿时不知所措！a 怎么可能即等于 1、也可以等于 2，还能等于三呢？
再看看题目发现 等号使用的双等号，在双等号时类型不一样的值作比较很可能会发生隐式转换！  
考虑到隐式转换，再想一下，如果 a 是一个基本类型，判断相等时 a 是不会变的，也就不会可以让 `a == 1 && a == 2 && a == 3` 满足，因此变量 a 是一个复杂类型。  
这时候就要了解隐式转换的一些内容。考虑下面几个表达式的结果：
```js
{} + {} == ?    // "[object Object][object Object]"
[] + {} == ?    // "[object Object]"
{} + [] == ?    // "[object Object]"
[] + [] == ?    // ""
"" + {} == ?    // "[object Object]"
"" + [] == ?    // ""
console.log(![]);   // false
console.log(!{});   // false
```
> 需要注意的是，在 Chrome 的控制台上，如果输入 `{} + []` 返回的却是数字 `0`，而使用 `console.log()` 方法返回的却是 `"[object Object]"`，同样的，在控制台上输入 `{} + 1`，返回的却是数字 `1`，而使用 `console.log()` 时，返回的却是 `"[object Object]1"`！让人捉摸不定。
### 复杂类型的隐式转换
在 JavaScript 中，基本类型主要有这么几个：`string`,`number`,`boolean`,`undefined`,`null`。这里主要讨论前三个类型与对象作运算的结果。下面是转换的三组结论：  
#### 1. 对象转换成布尔类型，得到的是真值
比如：
```js
var a = [],b = {};
// 将会打印出 yes
if(a && b){ console.log("yes"); }
```
#### 2. 对象转换成字符串
这个在转换时会有几个步骤，具体如下：
1. 如果对象具有 `toString()` 方法，则调用这个方法，然后得到一个原始值，用这个原始值再做运算（这时候再有隐式转换就是原始值之间的事了）  
2. 如果对象没有 `toString()` 方法，或者这个方法并不返回一个原始值，则调用对象中的 `valueOf()` 方法，得到一个原始值，然后再将这个原始值转换成字符串，得到后的这个值再做运算处理。
3. 如果该对象无法从 `toString()` 和 `valueOf()` 中获得一个原始值，那么这时就会抛出一个类型错误。  

每个通过对象字面量的形式实例化的对象都会继承 `Object.prototype` 上的方法，原型上就有 `toString()` 和 `valueOf()` 方法。因此会出现上面代码中的情况。比如：
```js
var a = {}, b = [];
// 下面是系统会返回的转化后的原始值
a.toString();       // "[object Object]"
b.toString();       // ""
```
#### 3. 对象转成数字
这个跟转成字符串很相似，具体如下：  
1. 如果对象具有 `valueOf()` 方法，则调用这个方法，然后返回一个原始值，并将这个原始值转换成数字，然后再做运算；
2. 如果对象没有 `valueOf()` 方法，则调用 `toString()` 方法，然后返回一个原始值，并将这个原始值转成数字，然后再做运算；
3. 如果这个对象 既没有 `valueOf()` 方法，也没有 `toString()` 方法，则就会抛出一个类型错误；  
> 需要注意的是：数组或者对象使用 `valueOf()` 方法转换时返回的是一个对象，而不会返回原始值，因此对象、数组转换则会调用 `toString()` 方法。
```js
console.log({} + 1);    // "[object Object]1"
console.log(1 + {});    // "1[object Object]"
```
说了那么多，还没有解答正题，如何做到等式成立呢？显然变量 a 是个对象，而且它的 `toString()` 或者 `valueOf` 方法被改写了。不再让 `toString()` 或 `valueOf()` 有原来的作用。 为了避免隐患，最好不用直接修改对象原型上的 `toString` 或者 `valueOf()` 方法，而应该在现有的对象上添加，这样可以尽量避免污染别的程序。  
```js
var a = {
    idx: 0,
    valueOf(){
        return ++ this.idx;
    }
}
console.log(a == 1 && a == 2 && a == 3);    // true
```
或者：
```js
var a = {
    idx: 0,
    toString(){
        return ++ this.idx;
    }
}
```
或者：
```js
var a = {
    arr: [1,2,3],
    toString(){
        return this.arr.shift();
    }
}
```
等等吧，改写 `toString` 或者 `valueOf` 的方式有很多。